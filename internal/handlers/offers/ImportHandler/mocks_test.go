// Code generated by MockGen. DO NOT EDIT.
// Source: import_handler.go
//
// Generated by this command:
//
//	mockgen -source import_handler.go -destination mocks_test.go -package importHandler_test
//

// Package importHandler_test is a generated GoMock package.
package importHandler_test

import (
	"bytes"
	context "context"
	io "io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	reflect "reflect"
	"testing"

	gomock "go.uber.org/mock/gomock"

	importHandler "github.com/sergunchig/merchant_exp.git/internal/handlers/offers/ImportHandler"
)

// MockofferLogger is a mock of offerLogger interface.
type MockofferLogger struct {
	ctrl     *gomock.Controller
	recorder *MockofferLoggerMockRecorder
	isgomock struct{}
}

// MockofferLoggerMockRecorder is the mock recorder for MockofferLogger.
type MockofferLoggerMockRecorder struct {
	mock *MockofferLogger
}

// NewMockofferLogger creates a new mock instance.
func NewMockofferLogger(ctrl *gomock.Controller) *MockofferLogger {
	mock := &MockofferLogger{ctrl: ctrl}
	mock.recorder = &MockofferLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockofferLogger) EXPECT() *MockofferLoggerMockRecorder {
	return m.recorder
}

// Error mocks base method.
func (m *MockofferLogger) Error(msg string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Error", msg)
}

// Error indicates an expected call of Error.
func (mr *MockofferLoggerMockRecorder) Error(msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockofferLogger)(nil).Error), msg)
}

// MockimportServices is a mock of importServices interface.
type MockimportServices struct {
	ctrl     *gomock.Controller
	recorder *MockimportServicesMockRecorder
	isgomock struct{}
}

// MockimportServicesMockRecorder is the mock recorder for MockimportServices.
type MockimportServicesMockRecorder struct {
	mock *MockimportServices
}

// NewMockimportServices creates a new mock instance.
func NewMockimportServices(ctrl *gomock.Controller) *MockimportServices {
	mock := &MockimportServices{ctrl: ctrl}
	mock.recorder = &MockimportServicesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockimportServices) EXPECT() *MockimportServicesMockRecorder {
	return m.recorder
}

// ImportOffers mocks base method.
func (m *MockimportServices) ImportOffers(ctx context.Context, file string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ImportOffers", ctx, file)
	ret0, _ := ret[0].(error)
	return ret0
}

// ImportOffers indicates an expected call of ImportOffers.
func (mr *MockimportServicesMockRecorder) ImportOffers(ctx, file any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ImportOffers", reflect.TypeOf((*MockimportServices)(nil).ImportOffers), ctx, file)
}

// MockstorageService is a mock of storageService interface.
type MockstorageService struct {
	ctrl     *gomock.Controller
	recorder *MockstorageServiceMockRecorder
	isgomock struct{}
}

// MockstorageServiceMockRecorder is the mock recorder for MockstorageService.
type MockstorageServiceMockRecorder struct {
	mock *MockstorageService
}

// NewMockstorageService creates a new mock instance.
func NewMockstorageService(ctrl *gomock.Controller) *MockstorageService {
	mock := &MockstorageService{ctrl: ctrl}
	mock.recorder = &MockstorageServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockstorageService) EXPECT() *MockstorageServiceMockRecorder {
	return m.recorder
}

// SaveFile mocks base method.
func (m *MockstorageService) SaveFile(in io.Reader, fileName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveFile", in, fileName)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveFile indicates an expected call of SaveFile.
func (mr *MockstorageServiceMockRecorder) SaveFile(in, fileName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveFile", reflect.TypeOf((*MockstorageService)(nil).SaveFile), in, fileName)
}

func TestImportHandler(t *testing.T){
	tests := []struct{
		name string
		storageErr error
		importErr error
	}{
		{name: "normal case", storageErr: nil, importErr: nil},
	}

	ctrl := gomock.NewController(t)

	importService := NewMockimportServices(ctrl)
	storageService := NewMockstorageService(ctrl)
	log := NewMockofferLogger(ctrl)

	handler := importHandler.New(importService, storageService, log)

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	part, err := writer.CreateFormFile("file", "file.txt")
	if err != nil {
		t.Fatal("dont create test file")
	}
	part.Write([]byte("file content"))
	writer.Close()

	for _, test := range tests{
		ctx := context.Background()
		req := httptest.NewRequest(http.MethodPost, "/uploadandimport/", body)
		req.Header.Set("Content-Type", writer.FormDataContentType())

		file, _, err := req.FormFile("file")
		if err != nil{
			t.Fatal(err.Error())
		}
		
		storageService.EXPECT().SaveFile(file, "./storage/excelfile.xlsx").Return(test.storageErr).Times(1)
		importService.EXPECT().ImportOffers(ctx,"./storage/excelfile.xlsx").Return(test.importErr).Times(1)
		log.EXPECT().Error(gomock.Any()).AnyTimes()


		rw := httptest.NewRecorder()

		handler.UploadAndImportHandler(rw, req)

		t.Run(test.name, func (t *testing.T)  {
			if status := rw.Code; status != http.StatusOK {
				t.Errorf("Returned status code %d", rw.Code)
			}
		})
	}

}