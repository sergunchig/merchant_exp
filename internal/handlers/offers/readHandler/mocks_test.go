// Code generated by MockGen. DO NOT EDIT.
// Source: read_handler.go
//
// Generated by this command:
//
//	mockgen -source read_handler.go -destination mocks_test.go -package readHandler_test
//

// Package readHandler_test is a generated GoMock package.
package readHandler_test

import (
	context "context"
	"fmt"
	//"fmt"
	"net/http"
	"net/http/httptest"
	reflect "reflect"
	"testing"

	dto "github.com/sergunchig/merchant_exp.git/dto"
	"github.com/sergunchig/merchant_exp.git/internal/handlers/offers/readHandler"

	gomock "go.uber.org/mock/gomock"
)

// MockreadService is a mock of readService interface.
type MockreadService struct {
	ctrl     *gomock.Controller
	recorder *MockreadServiceMockRecorder
	isgomock struct{}
}

// MockreadServiceMockRecorder is the mock recorder for MockreadService.
type MockreadServiceMockRecorder struct {
	mock *MockreadService
}

// NewMockreadService creates a new mock instance.
func NewMockreadService(ctrl *gomock.Controller) *MockreadService {
	mock := &MockreadService{ctrl: ctrl}
	mock.recorder = &MockreadServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockreadService) EXPECT() *MockreadServiceMockRecorder {
	return m.recorder
}

// GetOffersAsync mocks base method.
func (m *MockreadService) GetOffersAsync(ctx context.Context) ([]dto.OfferDto, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOffersAsync", ctx)
	ret0, _ := ret[0].([]dto.OfferDto)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOffersAsync indicates an expected call of GetOffersAsync.
func (mr *MockreadServiceMockRecorder) GetOffersAsync(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOffersAsync", reflect.TypeOf((*MockreadService)(nil).GetOffersAsync), ctx)
}

// MockofferLogger is a mock of offerLogger interface.
type MockofferLogger struct {
	ctrl     *gomock.Controller
	recorder *MockofferLoggerMockRecorder
	isgomock struct{}
}

// MockofferLoggerMockRecorder is the mock recorder for MockofferLogger.
type MockofferLoggerMockRecorder struct {
	mock *MockofferLogger
}

// NewMockofferLogger creates a new mock instance.
func NewMockofferLogger(ctrl *gomock.Controller) *MockofferLogger {
	mock := &MockofferLogger{ctrl: ctrl}
	mock.recorder = &MockofferLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockofferLogger) EXPECT() *MockofferLoggerMockRecorder {
	return m.recorder
}

// Error mocks base method.
func (m *MockofferLogger) Error(msg string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Error", msg)
}

// Error indicates an expected call of Error.
func (mr *MockofferLoggerMockRecorder) Error(msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Error", reflect.TypeOf((*MockofferLogger)(nil).Error), msg)
}

func TestReadHandler(t *testing.T){
	tests := []struct{
		name string
		dtos []dto.OfferDto
		err error
		result int
	}{
		{"normal case", []dto.OfferDto{
			dto.OfferDto{
				OfferId: 1,
				Name: "Bear",
				Price: 14,
				Available: true,
			},
			dto.OfferDto{
				OfferId: 2,
				Name: "white bear",
				Price: 16,
				Available: true,
			},
		}, nil, http.StatusOK},
		{"error case", nil, fmt.Errorf("Error"), http.StatusInternalServerError},
	}
	ctx := context.Background()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	service :=NewMockreadService(ctrl)
	log := NewMockofferLogger(ctrl)
	log.EXPECT().Error(gomock.Any()).AnyTimes()

	hndlr := readHandler.New(service, log)

	for _,test := range tests{
		service.EXPECT().GetOffersAsync(ctx).Return(test.dtos, test.err).Times(1)	
		rr := httptest.NewRecorder()
		req, err := http.NewRequest(http.MethodGet, "/getoffers/", nil)
		if err != nil {
			t.Error()
			continue
		}
		hndlr.GetOffersAsync(rr, req)
		t.Run(test.name, func(t *testing.T) {
			if status := rr.Code; status != test.result {
				t.Errorf("Returned status code %d", rr.Code)
			}
		})
	}
}
